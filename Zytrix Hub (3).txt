-- Load Rayfield UI Library
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

-- Get services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera

-- Variables for features
local espEnabled = false
local espColor = Color3.fromRGB(255, 0, 0) -- Default red
local aimbotEnabled = false
local camlockEnabled = false
local tracerEnabled = false
local targetPlayer = nil

-- Helper Functions
local function getNearestPlayer()
    local closest = nil
    local closestDistance = math.huge
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
            if distance < closestDistance then
                closest = player
                closestDistance = distance
            end
        end
    end
    
    return closest
end

-- Function to apply ESP to a player with thicker outlines
local function applyESPToPlayer(player)
    if player == LocalPlayer then return end

    if player.Character then
        -- Check if existing ESP already exists
        local existingESP = player.Character:FindFirstChild("ZytrixESP_Highlight")
        if existingESP then existingESP:Destroy() end

        -- Create highlight for the whole character
        local highlight = Instance.new("Highlight")
        highlight.Name = "ZytrixESP_Highlight"
        highlight.FillColor = espColor
        highlight.OutlineColor = espColor
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 0
        highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        highlight.Adornee = player.Character
        highlight.Parent = player.Character
    end
end

local function updateESPOnAllPlayers()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then -- Skip myself
            applyESPToPlayer(player)
        end
    end
end

local function updateAllESPColors()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then -- Skip myself
            local esp = player.Character:FindFirstChild("ZytrixESP_Highlight")
            if esp and esp:IsA("Highlight") then
                esp.FillColor = espColor
                esp.OutlineColor = espColor
            end
        end
    end
end

local Window = Rayfield:CreateWindow({
    Name = "ZytrixHub",
    LoadingTitle = "Loading...",
    LoadingSubtitle = "By mark074271",
    ConfigurationSaving = {
        Enabled = false,
        FolderName = nil,
        FileName = nil
    },
    Discord = {
        Enabled = false,
        Invite = "",
        RememberJoins = true
    },
    KeySystem = false
})

local CombatTab = Window:CreateTab("Combat", 4483362458)
local LocalPlayerTab = Window:CreateTab("LocalPlayer", 4483362458)

local ESPToggle = CombatTab:CreateToggle({
    Name = "ESP",
    Info = "ESP All Players Exclude Yourself",
    CurrentValue = false,
    Flag = "ESP_Toggle",
    Callback = function(Value)
        espEnabled = Value
        
        if Value then
            -- Apply ESP to all existing players
            updateESPOnAllPlayers()
            
            -- Setup continuous ESP update
            RunService:BindToRenderStep("ESP_Update", 200, function()
                if not espEnabled then 
                    RunService:UnbindFromRenderStep("ESP_Update")
                    return
                end
                updateESPOnAllPlayers()
            end)
            
            -- New players
            Players.PlayerAdded:Connect(function(player)
                player.CharacterAdded:Connect(function()
                    if espEnabled then
                        task.wait(1)
                        applyESPToPlayer(player)
                    end
                end)
            end)
            
            -- Respawned characters
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    player.CharacterAdded:Connect(function()
                        if espEnabled then
                            task.wait(1)
                            applyESPToPlayer(player)
                        end
                    end)
                end
            end
            
        else
            -- Fully remove ESP Highlights from all players
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    for _, descendant in pairs(player.Character:GetDescendants()) do
                        if descendant:IsA("Highlight") and descendant.Name == "ZytrixESP_Highlight" then
                            descendant:Destroy()  -- Make sure you're destroying the right ESP Highlight
                        end
                    end
                end
            end

            -- Unbind the ESP update when turning off
            RunService:UnbindFromRenderStep("ESP_Update")
        end
    end,
})

-- Replace dropdown with color picker for ESP
local ESPColorPicker = CombatTab:CreateColorPicker({
    Name = "ESP Color",
    Color = Color3.fromRGB(255, 0, 0), -- Default red
    Flag = "ESP_ColorPicker",
    Callback = function(Value)
        espColor = Value
        -- Update all ESP colors
        updateAllESPColors()
    end
})

-- Enhanced Aimlock with Cyberpunk Buttons (FULLY FIXED)

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

-- Local variables
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera

-- Aimlock variables
local aimbotEnabled = false
local aimlockActive = false  -- Separate variable for active state vs enabled toggle
local clickToChangeEnabled = true -- Set to true by default for easier targeting
local targetPlayer = nil
local aimlockConnection = nil -- Store the RenderStepped connection

-- Function to get nearest player
local function getNearestPlayer()
    local closest = nil
    local closestDistance = math.huge
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and 
           player.Character:FindFirstChild("HumanoidRootPart") and 
           player.Character:FindFirstChild("Humanoid") and 
           player.Character.Humanoid.Health > 0 then
            
            local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
            if distance < closestDistance then
                closestDistance = distance
                closest = player
            end
        end
    end
    
    return closest
end

-- Create a notification function
local function showNotification(title, content, duration)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = duration or 2
    })
end

-- Create a super duper ultra ultimate smooth cyberpunk button with label
local function createCyberpunkButton(text, position, size, backgroundColor, cornerRadius, rotationSpeed, labelText, callback)
    local buttonGui = Instance.new("ScreenGui")
    buttonGui.Name = text .. "CyberpunkButton"
    buttonGui.Parent = game.CoreGui
    
    local containerFrame = Instance.new("Frame")
    containerFrame.Size = UDim2.new(0, size.X.Offset + 20, 0, size.Y.Offset + 40) -- Extra height for label
    containerFrame.Position = position
    containerFrame.BackgroundTransparency = 1
    containerFrame.Parent = buttonGui
    
    -- Label above button
    local labelTextLabel = Instance.new("TextLabel")
    labelTextLabel.Size = UDim2.new(1, 0, 0, 20)
    labelTextLabel.Position = UDim2.new(0, 0, 0, 0)
    labelTextLabel.Text = labelText
    labelTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    labelTextLabel.Font = Enum.Font.GothamSemibold
    labelTextLabel.TextSize = 14
    labelTextLabel.BackgroundTransparency = 1
    labelTextLabel.Parent = containerFrame
    
    local buttonFrame = Instance.new("Frame")
    buttonFrame.Size = size
    buttonFrame.Position = UDim2.new(0.5, -size.X.Offset/2, 0, 20) -- Position below label
    buttonFrame.BackgroundColor3 = backgroundColor
    buttonFrame.Parent = containerFrame
    
    local cornerInstance = Instance.new("UICorner")
    cornerInstance.CornerRadius = UDim.new(0, cornerRadius)
    cornerInstance.Parent = buttonFrame
    
    local buttonOutline = Instance.new("UIStroke")
    buttonOutline.Color = Color3.fromRGB(255, 255, 255)
    buttonOutline.Thickness = 2
    buttonOutline.Parent = buttonFrame
    
    local buttonLabel = Instance.new("TextLabel")
    buttonLabel.Size = UDim2.new(1, 0, 1, 0)
    buttonLabel.Text = text
    buttonLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    buttonLabel.TextScaled = true
    buttonLabel.Font = Enum.Font.GothamBold
    buttonLabel.BackgroundTransparency = 1
    buttonLabel.Parent = buttonFrame
    
    -- Make the container draggable
    local dragging = false
    local dragInput
    local dragStart
    local startPos
    
    local function updateDrag(input)
        local delta = input.Position - dragStart
        containerFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
    
    containerFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = containerFrame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    containerFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            updateDrag(input)
        end
    end)
    
    -- Button hover and click effects
    buttonFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            TweenService:Create(buttonFrame, TweenInfo.new(0.1), {Size = UDim2.new(size.X.Scale, size.X.Offset - 5, size.Y.Scale, size.Y.Offset - 5), Position = UDim2.new(0.5, -size.X.Offset/2 + 2.5, 0, 20 + 2.5)}):Play()
            if callback then callback() end
        end
    end)
    
    buttonFrame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            TweenService:Create(buttonFrame, TweenInfo.new(0.1), {Size = size, Position = UDim2.new(0.5, -size.X.Offset/2, 0, 20)}):Play()
        end
    end)
    
    -- Hover effect
    local isHovering = false
    
    buttonFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            isHovering = true
            TweenService:Create(buttonFrame, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(backgroundColor.R * 1.2, backgroundColor.G * 1.2, backgroundColor.B * 1.2)}):Play()
        end
    end)
    
    buttonFrame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            isHovering = false
            TweenService:Create(buttonFrame, TweenInfo.new(0.2), {BackgroundColor3 = backgroundColor}):Play()
        end
    end)
    
    -- Rainbow outline effect
    local hue = 0
    local connection
    connection = RunService.RenderStepped:Connect(function(dt)
        if not buttonFrame or not buttonFrame.Parent then
            connection:Disconnect()
            return
        end
        
        -- Rainbow outline
        hue = (hue + dt * 0.1) % 1
        buttonOutline.Color = Color3.fromHSV(hue, 1, 1)
        
        -- Rotation effect (cyberpunk style)
        if rotationSpeed > 0 then
            buttonFrame.Rotation = (buttonFrame.Rotation + dt * 60 * rotationSpeed) % 360
        end
    end)
    
    return buttonGui
end

-- Function to start aimlock
local function startAimlock()
    -- Don't start if not enabled
    if not aimbotEnabled then return end
    
    -- Mark as active
    aimlockActive = true
    
    -- Stop any existing aimlock
    if aimlockConnection then
        aimlockConnection:Disconnect()
        aimlockConnection = nil
    end
    
    -- Start new aimlock
    aimlockConnection = RunService:BindToRenderStep("Aimlock", Enum.RenderPriority.Camera.Value, function()
        -- Make sure aimlock is still active
        if not aimlockActive then
            RunService:UnbindFromRenderStep("Aimlock")
            aimlockConnection = nil
            return
        end
        
        -- If no target or target left/died, find nearest
        if not targetPlayer or 
           not targetPlayer.Character or 
           not targetPlayer.Character:FindFirstChild("HumanoidRootPart") or
           not targetPlayer.Character:FindFirstChild("Humanoid") or
           targetPlayer.Character.Humanoid.Health <= 0 then
            
            targetPlayer = getNearestPlayer()
            if not targetPlayer then return end
        end
        
        -- Check if player is alive
        if not LocalPlayer.Character or 
           not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or
           not LocalPlayer.Character:FindFirstChild("Humanoid") or
           LocalPlayer.Character.Humanoid.Health <= 0 then
            return
        end
        
        -- Get target root part
        local root = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not root then return end

        -- Face target (Aimlock will only affect character orientation)
        local myRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if myRoot then
            local dir = (root.Position - myRoot.Position).Unit
            myRoot.CFrame = CFrame.lookAt(myRoot.Position, myRoot.Position + Vector3.new(dir.X, 0, dir.Z))
        end
    end)
    
    showNotification("Aimlock Active", "Now aiming at target: " .. targetPlayer.Name, 2)
end

-- Function to stop aimlock
local function stopAimlock()
    aimlockActive = false
    
    if aimlockConnection then
        RunService:UnbindFromRenderStep("Aimlock")
        aimlockConnection = nil
    end
    
    showNotification("Aimlock Paused", "Not aiming at target", 2)
end

-- IMPROVED BUTTON DESTRUCTION FUNCTION - 100% GUARANTEED TO DESTROY BUTTONS
local function superDestroyAllButtons()
    -- First try the direct approach
    pcall(function()
        if zKeyButton then
            zKeyButton:Destroy()
            zKeyButton = nil
        end
    end)
    
    pcall(function()
        if vKeyButton then
            vKeyButton:Destroy()
            vKeyButton = nil
        end
    end)
    
    -- Then search CoreGui for any buttons with the same names
    pcall(function()
        for _, v in pairs(game.CoreGui:GetChildren()) do
            if v.Name == "ZCyberpunkButton" then
                v:Destroy()
            end
        end
    end)
    
    pcall(function()
        for _, v in pairs(game.CoreGui:GetChildren()) do
            if v.Name == "VCyberpunkButton" then
                v:Destroy()
            end
        end
    end)
    
    -- Finally, do a broader search for any CyberpunkButtons
    pcall(function()
        for _, gui in pairs(game.CoreGui:GetChildren()) do
            if gui:IsA("ScreenGui") and (
                gui.Name:find("CyberpunkButton") and 
                (gui.Name:find("Z") or gui.Name:find("V"))
            ) then
                gui:Destroy()
            end
        end
    end)
    
    if inputConnection then
        inputConnection:Disconnect()
        inputConnection = nil
    end
end

-- Function to create buttons
local function createButtons()
    -- Create Z button for click-to-change functionality with label
    zKeyButton = createCyberpunkButton(
        "Z", 
        UDim2.new(0.05, 0, 0.05, 0), -- Position at top
        UDim2.new(0, 40, 0, 40), 
        Color3.fromRGB(80, 80, 80), 
        10, -- rounded corner
        0.5, -- rotation speed
        "Click to Change Target", -- Label text
        function()
            -- Toggle click-to-change mode
            clickToChangeEnabled = not clickToChangeEnabled
            
            if clickToChangeEnabled then
                showNotification("Click To Change Target", "Enabled - Click on a player to target", 2)
            else
                showNotification("Click To Change Target", "Disabled - Using nearest player", 2)
            end
        end
    )
    
    -- Create V button for toggling aimlock ACTIVE/INACTIVE state (not destroy buttons)
    vKeyButton = createCyberpunkButton(
        "V", 
        UDim2.new(0.05, 50, 0.05, 0),
        UDim2.new(0, 40, 0, 40), 
        Color3.fromRGB(80, 80, 80), 
        10,
        0.5,
        "Toggle Aiming On/Off",
        function()
            -- Toggle just the aimlock ACTIVE state - keeps buttons
            if aimlockActive then
                stopAimlock()
            else
                startAimlock()
            end
        end
    )
end

-- Complete disable function - ONLY called when toggle is turned off
local function disableAimlock()
    -- First stop the actual aimlock functionality
    aimlockActive = false
    aimbotEnabled = false
    
    if aimlockConnection then
        RunService:UnbindFromRenderStep("Aimlock")
        aimlockConnection = nil
    end

    -- Then destroy all the buttons
    superDestroyAllButtons()

    clickToChangeEnabled = true
    targetPlayer = nil

    showNotification("Aimlock System Disabled", "All aimlock functionality turned off", 2)
end

-- Global variables for the buttons
local zKeyButton = nil
local vKeyButton = nil
local inputConnection = nil

-- Aimlock Toggle Function (CORRECTLY FIXED)
local AimbotToggle = CombatTab:CreateToggle({
    Name = "Aimlock",
    Info = "Locks Your Character on Near Player or Clicked Player (Off Shiftlock)",
    CurrentValue = false,
    Flag = "Aimbot_Toggle",
    Callback = function(Value)
        -- Handle toggling off first
        if not Value then
            -- Only call this when the toggle is turned off - destroys buttons
            disableAimlock()
            return
        end
        
        -- Now handle turning on
        aimbotEnabled = true
        
        -- Create the buttons using the separate function
        createButtons()

        -- Initial target
        targetPlayer = getNearestPlayer()
        if targetPlayer then
            showNotification("Click another player to change target", "Target: " .. targetPlayer.Name, 2)
        end

        -- Clean up old connection if it exists
        if inputConnection then
            inputConnection:Disconnect()
            inputConnection = nil
        end
        
        -- Click or Touch to change target
        inputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if not aimbotEnabled or gameProcessed then return end
            
            -- Z key toggles click-to-change functionality
            if input.KeyCode == Enum.KeyCode.Z then
                clickToChangeEnabled = not clickToChangeEnabled
                
                if clickToChangeEnabled then
                    showNotification("Click To Change Target", "Enabled - Click on a player to target", 2)
                else
                    showNotification("Click To Change Target", "Disabled - Using nearest player", 2)
                end
                return
            end
            
            -- V key toggles active aiming state (not destroy buttons)
            if input.KeyCode == Enum.KeyCode.V then
                if aimlockActive then
                    stopAimlock()
                else
                    startAimlock()
                end
                return
            end
            
            -- Only process clicks if click-to-change is enabled
            if not clickToChangeEnabled then return end
            
            -- Handle both mouse clicks and touch input
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                local target = Mouse.Target
                if target then
                    local model = target:FindFirstAncestorOfClass("Model")
                    if model then
                        local player = Players:GetPlayerFromCharacter(model)
                        if player and player ~= LocalPlayer then
                            -- Check if player is alive
                            if player.Character and 
                               player.Character:FindFirstChild("Humanoid") and 
                               player.Character.Humanoid.Health > 0 then
                                
                                targetPlayer = player
                                showNotification("Target Changed", "Now targeting: " .. player.Name, 1.5)
                            end
                        end
                    end
                end
            end
        end)

        -- Start the aimlock active by default
        startAimlock()
    end
})

-- Enhanced Camlock with INSTANT SNAP BACK and NO DELAY

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

-- Local variables
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = workspace.CurrentCamera

-- Camlock variables
local camlockEnabled = false
local camlockActive = false
local clickToChangeEnabled = true
local targetPlayer = nil
local targetBodyPart = "Head"
local camlockConnection = nil
local lastInputTime = 0
local inputCooldown = 0.1 -- Cooldown in seconds

-- Function to get nearest player
local function getNearestPlayer()
    local closest = nil
    local closestDistance = math.huge
    
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and 
           player.Character:FindFirstChild("HumanoidRootPart") and 
           player.Character:FindFirstChild("Humanoid") and 
           player.Character.Humanoid.Health > 0 then
            
            local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
            if distance < closestDistance then
                closestDistance = distance
                closest = player
            end
        end
    end
    
    return closest
end

-- Create a notification function
local function showNotification(title, content, duration)
    Rayfield:Notify({
        Title = title,
        Content = content,
        Duration = duration or 2
    })
end

-- Create a super duper ultra ultimate smooth cyberpunk button with label
local function createCyberpunkButton(text, position, size, backgroundColor, cornerRadius, rotationSpeed, labelText, callback)
    local buttonGui = Instance.new("ScreenGui")
    buttonGui.Name = text .. "CyberpunkButton"
    buttonGui.Parent = game.CoreGui
    
    local containerFrame = Instance.new("Frame")
    containerFrame.Size = UDim2.new(0, size.X.Offset + 20, 0, size.Y.Offset + 40)
    containerFrame.Position = position
    containerFrame.BackgroundTransparency = 1
    containerFrame.Parent = buttonGui
    
    -- Label above button
    local labelTextLabel = Instance.new("TextLabel")
    labelTextLabel.Size = UDim2.new(1, 0, 0, 20)
    labelTextLabel.Position = UDim2.new(0, 0, 0, 0)
    labelTextLabel.Text = labelText
    labelTextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    labelTextLabel.Font = Enum.Font.GothamSemibold
    labelTextLabel.TextSize = 14
    labelTextLabel.BackgroundTransparency = 1
    labelTextLabel.Parent = containerFrame
    
    local buttonFrame = Instance.new("Frame")
    buttonFrame.Size = size
    buttonFrame.Position = UDim2.new(0.5, -size.X.Offset/2, 0, 20)
    buttonFrame.BackgroundColor3 = backgroundColor
    buttonFrame.Parent = containerFrame
    
    local cornerInstance = Instance.new("UICorner")
    cornerInstance.CornerRadius = UDim.new(0, cornerRadius)
    cornerInstance.Parent = buttonFrame
    
    local buttonOutline = Instance.new("UIStroke")
    buttonOutline.Color = Color3.fromRGB(255, 255, 255)
    buttonOutline.Thickness = 2
    buttonOutline.Parent = buttonFrame
    
    local buttonLabel = Instance.new("TextLabel")
    buttonLabel.Size = UDim2.new(1, 0, 1, 0)
    buttonLabel.Text = text
    buttonLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    buttonLabel.TextScaled = true
    buttonLabel.Font = Enum.Font.GothamBold
    buttonLabel.BackgroundTransparency = 1
    buttonLabel.Parent = buttonFrame
    
    -- Make the container draggable
    local dragging = false
    local dragInput
    local dragStart
    local startPos
    
    local function updateDrag(input)
        local delta = input.Position - dragStart
        containerFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
    
    containerFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = containerFrame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)
    
    containerFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)
    
    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            updateDrag(input)
        end
    end)
    
    -- Button hover and click effects
    buttonFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            TweenService:Create(buttonFrame, TweenInfo.new(0.1), {Size = UDim2.new(size.X.Scale, size.X.Offset - 5, size.Y.Scale, size.Y.Offset - 5), Position = UDim2.new(0.5, -size.X.Offset/2 + 2.5, 0, 20 + 2.5)}):Play()
            if callback then callback() end
        end
    end)
    
    buttonFrame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            TweenService:Create(buttonFrame, TweenInfo.new(0.1), {Size = size, Position = UDim2.new(0.5, -size.X.Offset/2, 0, 20)}):Play()
        end
    end)
    
    -- Hover effect
    local isHovering = false
    
    buttonFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            isHovering = true
            TweenService:Create(buttonFrame, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(backgroundColor.R * 1.2, backgroundColor.G * 1.2, backgroundColor.B * 1.2)}):Play()
        end
    end)
    
    buttonFrame.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            isHovering = false
            TweenService:Create(buttonFrame, TweenInfo.new(0.2), {BackgroundColor3 = backgroundColor}):Play()
        end
    end)
    
    -- Rainbow outline effect
    local hue = 0
    local connection
    connection = RunService.RenderStepped:Connect(function(dt)
        if not buttonFrame or not buttonFrame.Parent then
            connection:Disconnect()
            return
        end
        
        -- Rainbow outline
        hue = (hue + dt * 0.1) % 1
        buttonOutline.Color = Color3.fromHSV(hue, 1, 1)
        
        -- Rotation effect (cyberpunk style)
        if rotationSpeed > 0 then
            buttonFrame.Rotation = (buttonFrame.Rotation + dt * 60 * rotationSpeed) % 360
        end
    end)
    
    return buttonGui
end

-- Function to activate camlock with INSTANT SNAP BACK
local function activateCamlock()
    if not camlockEnabled then return end
    
    camlockActive = true
    
    -- Stop any existing camlock
    if camlockConnection then
        camlockConnection:Disconnect()
        camlockConnection = nil
    end
    
    -- Track user movement to know when to snap back
    local userMovingCamera = false
    
    -- Detect when user starts moving camera
    UserInputService.InputBegan:Connect(function(input)
        if not camlockActive then return end
        
        if input.UserInputType == Enum.UserInputType.MouseMovement or 
           input.UserInputType == Enum.UserInputType.Touch or
           input.UserInputType == Enum.UserInputType.Gamepad1 then
            userMovingCamera = true
            lastInputTime = tick()
        end
    end)
    
    -- Start AGGRESSIVE camlock with instant snap back
    camlockConnection = RunService.RenderStepped:Connect(function()
        if not camlockActive then
            camlockConnection:Disconnect()
            camlockConnection = nil
            return
        end
        
        -- Check if the user moved the camera recently
        local currentTime = tick()
        if currentTime - lastInputTime < inputCooldown then
            userMovingCamera = true
        else
            userMovingCamera = false
        end
        
        -- If no target or target left/died, find nearest
        if not targetPlayer or 
           not targetPlayer.Character or 
           not targetPlayer.Character:FindFirstChild("HumanoidRootPart") or
           not targetPlayer.Character:FindFirstChild("Humanoid") or
           targetPlayer.Character.Humanoid.Health <= 0 then
            
            targetPlayer = getNearestPlayer()
            if not targetPlayer then return end
        end
        
        -- Check if player is alive
        if not LocalPlayer.Character or 
           not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or
           not LocalPlayer.Character:FindFirstChild("Humanoid") or
           LocalPlayer.Character.Humanoid.Health <= 0 then
            return
        end
        
        -- Target the specified body part with fixed targeting
        local targetPart
        
        if targetBodyPart == "Head" and targetPlayer.Character:FindFirstChild("Head") then
            targetPart = targetPlayer.Character.Head
        elseif targetBodyPart == "Chest" then
            -- Try different chest parts with proper error checking
            if targetPlayer.Character:FindFirstChild("UpperTorso") then
                targetPart = targetPlayer.Character.UpperTorso
            elseif targetPlayer.Character:FindFirstChild("Torso") then
                targetPart = targetPlayer.Character.Torso
            else
                targetPart = targetPlayer.Character.HumanoidRootPart
            end
        elseif targetBodyPart == "Foot" then
            if targetPlayer.Character:FindFirstChild("RightFoot") then
                targetPart = targetPlayer.Character.RightFoot
            elseif targetPlayer.Character:FindFirstChild("LeftFoot") then
                targetPart = targetPlayer.Character.LeftFoot
            else
                targetPart = targetPlayer.Character.HumanoidRootPart
            end
        else
            targetPart = targetPlayer.Character.HumanoidRootPart
        end
        
        -- SUPER DUPER ULTRA ULTIMATE FAST SNAP BACK
        -- If user recently moved camera, check if we should snap back
        if not userMovingCamera then
            -- SUPER FAST INSTANT SNAP - current position but looking directly at target
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPart.Position)
        end
    end)
    
    showNotification("Camlock Activated", "Camera locked onto target: " .. targetPlayer.Name, 2)
end

-- Function to deactivate camlock
local function deactivateCamlock()
    camlockActive = false
    
    if camlockConnection then
        camlockConnection:Disconnect()
        camlockConnection = nil
    end
    
    showNotification("Camlock Deactivated", "Camera control returned to player", 2)
end

-- Function to destroy all GUI elements when toggled off
local function destroyAllButtons()
    if xKeyButton then
        xKeyButton:Destroy()
        xKeyButton = nil
    end
    
    if mKeyButton then
        mKeyButton:Destroy()
        mKeyButton = nil
    end
    
    if inputConnection then
        inputConnection:Disconnect()
        inputConnection = nil
    end
end

-- ADDING NEW IMPROVED BUTTON DESTRUCTION CODE (without removing existing code)
-- FIXED BUTTON DESTRUCTION FUNCTION - 100% GUARANTEED TO DESTROY BUTTONS
local function superDestroyAllButtons()
    -- First try the original method
    destroyAllButtons()
    
    -- Then use the enhanced aggressive button destruction
    -- Use pcall to ensure it doesn't error even if buttons don't exist
    pcall(function()
        for _, v in pairs(game.CoreGui:GetChildren()) do
            if v.Name == "XCyberpunkButton" then
                v:Destroy()
            end
        end
    end)
    
    pcall(function()
        for _, v in pairs(game.CoreGui:GetChildren()) do
            if v.Name == "MCyberpunkButton" then
                v:Destroy()
            end
        end
    end)
    
    -- Double-check cleanup all cyberpunk buttons
    pcall(function()
        for _, gui in pairs(game.CoreGui:GetChildren()) do
            if gui:IsA("ScreenGui") and (gui.Name:find("CyberpunkButton")) then
                gui:Destroy()
            end
        end
    end)
    
    -- Final cleanup of any remaining buttons
    xKeyButton = nil
    mKeyButton = nil
end

-- IMPROVED CLEANUP FUNCTION
local function superCleanupCamlock()
    -- First run the normal cleanup
    if camlockActive then
        deactivateCamlock()
    end
    
    -- Use the aggressive button destruction
    superDestroyAllButtons()
    
    -- Reset variables
    clickToChangeEnabled = true
    targetPlayer = nil
    camlockEnabled = false
    
    -- Extra notification to confirm cleanup
    showNotification("Camlock System", "All buttons and camlock functions disabled", 1.5)
end

-- Global variables for the buttons
local xKeyButton = nil
local mKeyButton = nil
local inputConnection = nil

-- Add dropdown for target body part selection
local CamlockPartDropdown = CombatTab:CreateDropdown({
    Name = "Camlock Target Part",
    Options = {"Head", "Chest", "Foot"},
    CurrentOption = "Head",
    Flag = "CamlockPart_Dropdown",
    Callback = function(Value)
        targetBodyPart = Value
        showNotification("Camlock Target Part", "Now aiming at: " .. Value, 1.5)
    end,
})

-- Camlock Toggle Function (SUPER INSTANT SNAP BACK)
local CamlockToggle = CombatTab:CreateToggle({
    Name = "Camlock",
    Info = "Camlock Near Player or Clicked Player (On Shiftlock)",
    CurrentValue = false,
    Flag = "Camlock_Toggle",
    Callback = function(Value)
        -- First deal with turning off - do this BEFORE changing the enabled flag
        if not Value then
            -- USE THE NEW SUPER CLEANUP FUNCTION INSTEAD
            superCleanupCamlock()
            return
        end
        
        -- Now handle turning on
        camlockEnabled = true
        
        -- Create X button for click-to-change functionality with label
        xKeyButton = createCyberpunkButton(
            "X", 
            UDim2.new(0.05, 0, 0.05, 100),
            UDim2.new(0, 40, 0, 40), 
            Color3.fromRGB(80, 80, 80), 
            10, -- rounded corner
            0.5, -- rotation speed
            "Click to Change Target", -- Label text
            function()
                -- Toggle click to change mode
                clickToChangeEnabled = not clickToChangeEnabled
                
                if clickToChangeEnabled then
                    showNotification("Click To Change Target", "Enabled - Click on a player to target", 2)
                else
                    showNotification("Click To Change Target", "Disabled - Using current target", 2)
                end
            end
        )
        
        -- Create M button for toggling camlock active state with label
        mKeyButton = createCyberpunkButton(
            "M", 
            UDim2.new(0.05, 50, 0.05, 100), -- Next to X button
            UDim2.new(0, 40, 0, 40), 
            Color3.fromRGB(80, 80, 80), 
            10, -- rounded corner
            0.5, -- rotation speed
            "Toggle Camlock Active", -- Label text
            function()
                -- Toggle camlock active state (not the toggle itself)
                if camlockActive then
                    deactivateCamlock()
                else
                    activateCamlock()
                end
            end
        )

        -- Only set new target if we don't have one already
        if not targetPlayer or not targetPlayer.Character or 
           not targetPlayer.Character:FindFirstChild("Humanoid") or
           targetPlayer.Character.Humanoid.Health <= 0 then
            
            targetPlayer = getNearestPlayer()
            
            -- Notify about initial target
            if targetPlayer then
                showNotification("Change Target By Clicking The Player", 
                                "Initially targeting: " .. targetPlayer.Name, 2)
            end
        end
        
        -- Clean up old connection if it exists
        if inputConnection then
            inputConnection:Disconnect()
            inputConnection = nil
        end
        
        -- New click-to-change connection
        inputConnection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if not camlockEnabled then return end
            
            -- Update the last input time for camera movement
            if input.UserInputType == Enum.UserInputType.MouseMovement or 
               input.UserInputType == Enum.UserInputType.Touch or 
               input.UserInputType == Enum.UserInputType.Gamepad1 then
                lastInputTime = tick()
            end
            
            -- M key toggles active state of camlock
            if input.KeyCode == Enum.KeyCode.M then
                if camlockActive then
                    deactivateCamlock()
                else
                    activateCamlock()
                end
                return
            end
            
            -- X key toggles click-to-change functionality
            if input.KeyCode == Enum.KeyCode.X then
                clickToChangeEnabled = not clickToChangeEnabled
                
                if clickToChangeEnabled then
                    showNotification("Click To Change Target", "Enabled - Click on a player to target", 2)
                else
                    showNotification("Click To Change Target", "Disabled - Using current target", 2)
                end
                return
            end
            
            -- Only process clicks if click-to-change is enabled
            if not clickToChangeEnabled then return end
            
            -- Detect mouse or touch input for changing target
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                -- Get the object the mouse or touch is hovering over
                local target = Mouse.Target
                if target then
                    -- Try to find a player from the target
                    local character = target:FindFirstAncestorOfClass("Model")
                    if character then
                        local player = Players:GetPlayerFromCharacter(character)
                        if player and player ~= LocalPlayer then
                            -- Check if the clicked player is alive before changing target
                            if player.Character and player.Character:FindFirstChild("Humanoid") and 
                               player.Character.Humanoid.Health > 0 then
                                
                                targetPlayer = player
                                showNotification("Camlock Target Changed", "Now targeting: " .. player.Name, 1.5)
                            end
                        end
                    end
                end
            end
        end)
    end
})

-- Create the Tracer Toggle with proper cleanup
local tracerDrawings = {} -- Move this outside to global scope so it persists

local TracerToggle = CombatTab:CreateToggle({
    Name = "Tracer",
    Info = "Tracer line and distance ESP",
    CurrentValue = false,
    Flag = "Tracer_Toggle",
    Callback = function(Value)
        tracerEnabled = Value
        
        if Value then -- If enabling tracers
            -- Create tracers for all players
            local function createTracerForPlayer(player)
                if player == LocalPlayer then return end
                
                -- Clean up existing tracers for this player if they exist
                if tracerDrawings[player] then
                    if tracerDrawings[player].line then 
                        tracerDrawings[player].line.Visible = false
                        tracerDrawings[player].line:Remove()
                    end
                    if tracerDrawings[player].text then
                        tracerDrawings[player].text.Visible = false
                        tracerDrawings[player].text:Remove()
                    end
                    if tracerDrawings[player].username then
                        tracerDrawings[player].username.Visible = false
                        tracerDrawings[player].username:Remove()
                    end
                    tracerDrawings[player] = nil
                end
                
                -- Create line
                local line = Drawing.new("Line")
                line.Visible = true
                line.Color = Color3.fromRGB(255, 255, 255)
                line.Thickness = 1
                line.Transparency = 1
                
                -- Create text for distance
                local distanceText = Drawing.new("Text")
                distanceText.Visible = true
                distanceText.Color = Color3.fromRGB(255, 255, 255)
                distanceText.Size = 18
                distanceText.Center = true
                distanceText.Outline = true
                
                -- Create username text
                local usernameText = Drawing.new("Text")
                usernameText.Visible = true
                usernameText.Color = Color3.fromRGB(255, 255, 255)
                usernameText.Size = 18
                usernameText.Center = true
                usernameText.Outline = true
                usernameText.Text = player.Name
                
                -- Store in our table
                tracerDrawings[player] = {
                    line = line,
                    text = distanceText,
                    username = usernameText
                }
            end
            
            -- Create tracers for all existing players
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    createTracerForPlayer(player)
                end
            end
            
            -- Handle new players joining
            local newPlayerConnection = Players.PlayerAdded:Connect(function(player)
                if not tracerEnabled then 
                    newPlayerConnection:Disconnect() 
                    return 
                end
                if player ~= LocalPlayer then
                    createTracerForPlayer(player)
                end
            end)
            
            -- Handle players leaving
            local playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
                if not tracerEnabled then 
                    playerRemovingConnection:Disconnect() 
                    return 
                end
                
                if tracerDrawings[player] then
                    if tracerDrawings[player].line then 
                        tracerDrawings[player].line.Visible = false
                        tracerDrawings[player].line:Remove()
                    end
                    if tracerDrawings[player].text then
                        tracerDrawings[player].text.Visible = false
                        tracerDrawings[player].text:Remove()
                    end
                    if tracerDrawings[player].username then
                        tracerDrawings[player].username.Visible = false
                        tracerDrawings[player].username:Remove()
                    end
                    tracerDrawings[player] = nil
                end
            end)
            
            -- Update all tracers in RenderStepped
            RunService:BindToRenderStep("TracerUpdate", 200, function()
                if not tracerEnabled then return end
                
                for player, drawings in pairs(tracerDrawings) do
                    if player and drawings then
                        if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                            drawings.line.Visible = false
                            drawings.text.Visible = false
                            drawings.username.Visible = false
                            continue -- Skip to next player
                        end
                        
                        -- Calculate positions
                        local rootPos = player.Character.HumanoidRootPart.Position
                        local rootVect = Camera:WorldToViewportPoint(rootPos)
                        
                        if rootVect.Z > 0 then -- Only show when in front of camera
                            -- Update line
                            drawings.line.Visible = true
                            drawings.line.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                            drawings.line.To = Vector2.new(rootVect.X, rootVect.Y)
                            
                            -- Calculate distance
                            local distance = (player.Character.HumanoidRootPart.Position - LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
                            
                            -- Update text
                            drawings.text.Visible = true
                            drawings.text.Text = math.floor(distance) .. "m"
                            drawings.text.Position = Vector2.new(rootVect.X, rootVect.Y - 25)
                            
                            -- Update username
                            drawings.username.Visible = true
                            drawings.username.Position = Vector2.new(rootVect.X, rootVect.Y - 45)
                        else
                            drawings.line.Visible = false
                            drawings.text.Visible = false
                            drawings.username.Visible = false
                        end
                    end
                end
            end)
        else -- If disabling tracers
            -- Unbind the update loop
            RunService:UnbindFromRenderStep("TracerUpdate")
            
            -- Clean up ALL Drawing objects
            for player, drawings in pairs(tracerDrawings) do
                if drawings then
                    if drawings.line then 
                        drawings.line.Visible = false
                        drawings.line:Remove()
                    end
                    if drawings.text then
                        drawings.text.Visible = false
                        drawings.text:Remove()
                    end
                    if drawings.username then
                        drawings.username.Visible = false
                        drawings.username:Remove()
                    end
                end
            end
            
            -- Clear the table completely
            table.clear(tracerDrawings)
        end
    end,
})

------------------ LOCAL PLAYER FEATURES ------------------
-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Original values
local originalWalkSpeed = 16
local originalJumpPower = 50
local originalGravity = 196.2

-- Selected values
local selectedWalkSpeed = originalWalkSpeed
local selectedJumpPower = originalJumpPower
local selectedGravity = originalGravity

-- Toggle states
local speedEnabled = false
local jumpEnabled = false
local gravityEnabled = false

-- Movement types
local movementTypes = {"Normal", "CFrame", "Velocity", "BodyVelocity"}
local jumpTypes = {"Normal", "BodyForce", "CustomHop", "SuperJump"}
local gravityTypes = {"Workspace", "BodyForce", "CharacterGravity", "CustomGravity"}

-- Selected types
local selectedSpeedType = "Normal"
local selectedJumpType = "Normal"
local selectedGravityType = "Workspace"

-- Connections and instances
local speedConnection = nil
local jumpConnection = nil
local gravityConnection = nil

-- Get character function with protection
local function getCharacter()
    local player = Players.LocalPlayer
    if not player then return nil, nil, nil end
    
    local character = player.Character
    if not character then
        return nil, nil, nil
    end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    
    return character, humanoid, rootPart
end

-- Cleanup functions
local function cleanupSpeed()
    if speedConnection then
        speedConnection:Disconnect()
        speedConnection = nil
    end
    
    local _, _, rootPart = getCharacter()
    if rootPart then
        local existingBV = rootPart:FindFirstChild("BVForSpeed")
        if existingBV then
            existingBV:Destroy()
        end
    end
end

local function cleanupJump()
    if jumpConnection then
        jumpConnection:Disconnect()
        jumpConnection = nil
    end
    
    local _, _, rootPart = getCharacter()
    if rootPart then
        local existingBF = rootPart:FindFirstChild("BFForJump")
        if existingBF then
            existingBF:Destroy()
        end
    end
end

local function cleanupGravity()
    if gravityConnection then
        gravityConnection:Disconnect()
        gravityConnection = nil
    end
    
    local _, _, rootPart = getCharacter()
    if rootPart then
        local existingAG = rootPart:FindFirstChild("AntiGravity")
        if existingAG then
            existingAG:Destroy()
        end
    end
end

-- Speed implementations
local function applyCFrameSpeed()
    cleanupSpeed()
    
    local _, humanoid, rootPart = getCharacter()
    if not humanoid or not rootPart then return end
    
    -- Connection with improved error handling for CFrame
    speedConnection = RunService.Heartbeat:Connect(function()
        if not speedEnabled or selectedSpeedType ~= "CFrame" then
            cleanupSpeed()
            return
        end
        
        local _, currentHumanoid, currentRootPart = getCharacter()
        if not currentHumanoid or not currentRootPart then return end
        
        local moveDirection = currentHumanoid.MoveDirection
        if moveDirection and moveDirection.Magnitude > 0 then
            -- Enhanced CFrame calculation for smoother movement
            local speedMultiplier = selectedWalkSpeed / originalWalkSpeed
            local movementDelta = moveDirection * speedMultiplier * 0.016
            
            pcall(function()
                -- Use CFrame.new to create a proper movement transformation
                local currentCFrame = currentRootPart.CFrame
                currentRootPart.CFrame = currentCFrame + movementDelta
            end)
        end
    end)
end

local function applyVelocitySpeed()
    cleanupSpeed()
    
    local _, humanoid, rootPart = getCharacter()
    if not humanoid or not rootPart then return end
    
    speedConnection = RunService.Heartbeat:Connect(function()
        if not speedEnabled or selectedSpeedType ~= "Velocity" then
            cleanupSpeed()
            return
        end
        
        local _, currentHumanoid, currentRootPart = getCharacter()
        if not currentHumanoid or not currentRootPart then return end
        
        local moveDirection = currentHumanoid.MoveDirection
        if moveDirection and moveDirection.Magnitude > 0 then
            pcall(function()
                local currentVelocity = currentRootPart.Velocity
                -- Apply velocity with consideration for Y axis to maintain proper jumping
                currentRootPart.Velocity = Vector3.new(
                    moveDirection.X * selectedWalkSpeed,
                    currentVelocity.Y,
                    moveDirection.Z * selectedWalkSpeed
                )
            end)
        end
    end)
end

local function applyBodyVelocitySpeed()
    cleanupSpeed()
    
    local _, humanoid, rootPart = getCharacter()
    if not humanoid or not rootPart then return end
    
    -- Create BodyVelocity instance using pcall for safety
    local bv
    pcall(function()
        bv = Instance.new("BodyVelocity")
        bv.Name = "BVForSpeed"
        bv.MaxForce = Vector3.new(9999999, 0, 9999999)
        bv.P = 1250
        bv.Parent = rootPart
    end)
    
    if not bv then return end
    
    speedConnection = RunService.Heartbeat:Connect(function()
        if not speedEnabled or selectedSpeedType ~= "BodyVelocity" then
            cleanupSpeed()
            return
        end
        
        local _, currentHumanoid, currentRootPart = getCharacter()
        if not currentHumanoid or not currentRootPart then 
            cleanupSpeed()
            return 
        end
        
        -- Check if BodyVelocity still exists
        local existingBV = currentRootPart:FindFirstChild("BVForSpeed")
        if not existingBV then
            -- Recreate if missing
            pcall(function()
                local newBV = Instance.new("BodyVelocity")
                newBV.Name = "BVForSpeed"
                newBV.MaxForce = Vector3.new(9999999, 0, 9999999)
                newBV.P = 1250
                newBV.Parent = currentRootPart
                existingBV = newBV
            end)
        end
        
        if existingBV then
            local moveDirection = currentHumanoid.MoveDirection
            if moveDirection and moveDirection.Magnitude > 0 then
                pcall(function()
                    existingBV.Velocity = moveDirection * selectedWalkSpeed
                end)
            else
                pcall(function()
                    existingBV.Velocity = Vector3.new(0, 0, 0)
                end)
            end
        end
    end)
end

-- Jump implementations
local function applyBodyForceJump()
    cleanupJump()
    
    local _, humanoid, rootPart = getCharacter()
    if not humanoid or not rootPart then return end
    
    -- Set JumpPower safely
    pcall(function()
        humanoid.JumpPower = 0
    end)
    
    jumpConnection = UserInputService.JumpRequest:Connect(function()
        if not jumpEnabled or selectedJumpType ~= "BodyForce" then
            cleanupJump()
            return
        end
        
        local _, currentHumanoid, currentRootPart = getCharacter()
        if not currentHumanoid or not currentRootPart then return end
        
        if currentHumanoid:GetState() ~= Enum.HumanoidStateType.Jumping and 
           currentHumanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
            
            local mass = currentRootPart.AssemblyMass or 1
            
            pcall(function()
                local bf = Instance.new("BodyForce")
                bf.Name = "BFForJump"
                bf.Force = Vector3.new(0, selectedJumpPower * mass * 10, 0)
                bf.Parent = currentRootPart
                
                game:GetService("Debris"):AddItem(bf, 0.1)
            end)
        end
    end)
end

local function applyCustomHopJump()
    cleanupJump()
    
    local _, humanoid, rootPart = getCharacter()
    if not humanoid or not rootPart then return end
    
    -- Set JumpPower safely
    pcall(function()
        humanoid.JumpPower = 0
    end)
    
    jumpConnection = UserInputService.JumpRequest:Connect(function()
        if not jumpEnabled or selectedJumpType ~= "CustomHop" then
            cleanupJump()
            return
        end
        
        local _, currentHumanoid, currentRootPart = getCharacter()
        if not currentHumanoid or not currentRootPart then return end
        
        if currentHumanoid:GetState() ~= Enum.HumanoidStateType.Jumping and 
           currentHumanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
            
            pcall(function()
                local currentVel = currentRootPart.Velocity
                if currentVel then
                    currentRootPart.Velocity = Vector3.new(currentVel.X, selectedJumpPower, currentVel.Z)
                end
            end)
        end
    end)
end

local function applySuperJump()
    cleanupJump()
    
    local _, humanoid, rootPart = getCharacter()
    if not humanoid or not rootPart then return end
    
    -- Set JumpPower safely
    pcall(function()
        humanoid.JumpPower = 0
    end)
    
    jumpConnection = UserInputService.JumpRequest:Connect(function()
        if not jumpEnabled or selectedJumpType ~= "SuperJump" then
            cleanupJump()
            return
        end
        
        local _, currentHumanoid, currentRootPart = getCharacter()
        if not currentHumanoid or not currentRootPart then return end
        
        if currentHumanoid:GetState() ~= Enum.HumanoidStateType.Jumping and 
           currentHumanoid:GetState() ~= Enum.HumanoidStateType.Freefall then
            
            pcall(function()
                -- Get the current look direction
                local lookVector = currentRootPart.CFrame.LookVector
                if lookVector then
                    -- First apply a CFrame boost upwards
                    currentRootPart.CFrame = currentRootPart.CFrame + Vector3.new(0, selectedJumpPower/10, 0)
                    
                    -- Then apply a velocity in the looking direction + upwards
                    currentRootPart.Velocity = Vector3.new(
                        lookVector.X * selectedWalkSpeed/2, 
                        selectedJumpPower, 
                        lookVector.Z * selectedWalkSpeed/2
                    )
                end
            end)
        end
    end)
end

-- Gravity implementations
local function applyBodyForceGravity()
    cleanupGravity()
    
    local _, _, rootPart = getCharacter()
    if not rootPart then return end
    
    pcall(function()
        local mass = rootPart.AssemblyMass or 1
        
        local antiGrav = Instance.new("BodyForce")
        antiGrav.Name = "AntiGravity"
        antiGrav.Force = Vector3.new(0, (196.2 - selectedGravity) * mass, 0)
        antiGrav.Parent = rootPart
    end)
end

local function applyCharacterGravity()
    cleanupGravity()
    
    local character = getCharacter()
    if not character then return end
    
    gravityConnection = RunService.Heartbeat:Connect(function()
        if not gravityEnabled or selectedGravityType ~= "CharacterGravity" then
            cleanupGravity()
            return
        end
        
        local _, _, rootPart = getCharacter()
        if rootPart and rootPart.Velocity then
            pcall(function()
                local currentVel = rootPart.Velocity
                rootPart.Velocity = Vector3.new(
                    currentVel.X, 
                    currentVel.Y - ((196.2 - selectedGravity) * 0.016), 
                    currentVel.Z
                )
            end)
        end
    end)
end

local function applyCustomGravity()
    cleanupGravity()
    
    local _, _, rootPart = getCharacter()
    if not rootPart then return end
    
    -- Set Gravity safely
    pcall(function()
        workspace.Gravity = 0
    end)
    
    gravityConnection = RunService.Heartbeat:Connect(function()
        if not gravityEnabled or selectedGravityType ~= "CustomGravity" then
            pcall(function()
                workspace.Gravity = originalGravity
            end)
            cleanupGravity()
            return
        end
        
        local _, _, currentRootPart = getCharacter()
        if currentRootPart and currentRootPart.Velocity then
            pcall(function()
                local gravityForce = Vector3.new(0, -selectedGravity * 0.016, 0)
                currentRootPart.Velocity = currentRootPart.Velocity + gravityForce
            end)
        end
    end)
end

-- Update functions
local function updateSpeed()
    local _, humanoid = getCharacter()
    if not humanoid then return end
    
    cleanupSpeed()
    
    if speedEnabled then
        if selectedSpeedType == "Normal" then
            pcall(function()
                humanoid.WalkSpeed = selectedWalkSpeed
            end)
        elseif selectedSpeedType == "CFrame" then
            pcall(function()
                humanoid.WalkSpeed = originalWalkSpeed
            end)
            applyCFrameSpeed()
        elseif selectedSpeedType == "Velocity" then
            pcall(function()
                humanoid.WalkSpeed = originalWalkSpeed
            end)
            applyVelocitySpeed()
        elseif selectedSpeedType == "BodyVelocity" then
            pcall(function()
                humanoid.WalkSpeed = originalWalkSpeed
            end)
            applyBodyVelocitySpeed()
        end
    else
        pcall(function()
            humanoid.WalkSpeed = originalWalkSpeed
        end)
    end
end

local function updateJump()
    local _, humanoid = getCharacter()
    if not humanoid then return end
    
    cleanupJump()
    
    if jumpEnabled then
        if selectedJumpType == "Normal" then
            pcall(function()
                humanoid.JumpPower = selectedJumpPower
            end)
        elseif selectedJumpType == "BodyForce" then
            applyBodyForceJump()
        elseif selectedJumpType == "CustomHop" then
            applyCustomHopJump()
        elseif selectedJumpType == "SuperJump" then
            applySuperJump()
        end
    else
        pcall(function()
            humanoid.JumpPower = originalJumpPower
        end)
    end
end

local function updateGravity()
    cleanupGravity()
    
    if gravityEnabled then
        if selectedGravityType == "Workspace" then
            pcall(function()
                workspace.Gravity = selectedGravity
            end)
        elseif selectedGravityType == "BodyForce" then
            applyBodyForceGravity()
        elseif selectedGravityType == "CharacterGravity" then
            applyCharacterGravity()
        elseif selectedGravityType == "CustomGravity" then
            applyCustomGravity()
        end
    else
        pcall(function()
            workspace.Gravity = originalGravity
        end)
    end
end

-- Character respawn handling
local characterAddedConnection
characterAddedConnection = Players.LocalPlayer.CharacterAdded:Connect(function(character)
    if character then
        local humanoid = character:WaitForChild("Humanoid", 5)
        if humanoid then
            originalWalkSpeed = humanoid.WalkSpeed
            originalJumpPower = humanoid.JumpPower
        end
        
        originalGravity = workspace.Gravity
        
        cleanupSpeed()
        cleanupJump()
        cleanupGravity()
        
        -- Delay applying effects to ensure character is fully loaded
        task.wait(0.5)
        
        if speedEnabled then updateSpeed() end
        if jumpEnabled then updateJump() end
        if gravityEnabled then updateGravity() end
    end
end)

-- Get initial values safely
pcall(function()
    local _, humanoid = getCharacter()
    if humanoid then
        originalWalkSpeed = humanoid.WalkSpeed
        originalJumpPower = humanoid.JumpPower
    end
end)

-- UI Elements
-- REORGANIZED WITH SLIDERS FIRST, THEN DROPDOWNS, THEN TOGGLES

-- SPEED SETTINGS --
-- Speed Value Slider (FIRST)
local SpeedSlider = LocalPlayerTab:CreateSlider({
    Name = "Walk Speed",
    Range = {0, 1000},
    Increment = 1,
    Suffix = "studs/s",
    CurrentValue = originalWalkSpeed,
    Flag = "WalkSpeed", 
    Callback = function(Value)
        if Value then
            selectedWalkSpeed = Value
            if speedEnabled then
                updateSpeed()
            end
        end
    end
})

-- Speed Type Dropdown (SECOND)
local SpeedTypeDropdown = LocalPlayerTab:CreateDropdown({
    Name = "Speed Modification Type",
    Options = movementTypes,
    CurrentOption = selectedSpeedType,
    Flag = "SpeedType",
    Callback = function(Option)
        if Option then
            selectedSpeedType = Option
            if speedEnabled then
                updateSpeed()
            end
        end
    end
})

-- Speed Toggle (LAST)
local SpeedToggle = LocalPlayerTab:CreateToggle({
    Name = "Apply Speed",
    CurrentValue = false,
    Flag = "SpeedEnabled", 
    Callback = function(Value)
        if Value ~= nil then
            speedEnabled = Value
            updateSpeed()
            
            if Value then
                pcall(function()
                    Rayfield:Notify({
                        Title = "Speed Modifier",
                        Content = "Speed set to " .. selectedWalkSpeed .. " using " .. selectedSpeedType .. " method",
                        Duration = 2
                    })
                end)
            else
                pcall(function()
                    Rayfield:Notify({
                        Title = "Speed Modifier",
                        Content = "Speed reset to default: " .. originalWalkSpeed,
                        Duration = 2
                    })
                end)
            end
        end
    end
})

-- JUMP SETTINGS --
-- Jump Power Slider (FIRST)
local JumpSlider = LocalPlayerTab:CreateSlider({
    Name = "Jump Power",
    Range = {0, 1000},
    Increment = 1,
    Suffix = "power",
    CurrentValue = originalJumpPower,
    Flag = "JumpPower", 
    Callback = function(Value)
        if Value then
            selectedJumpPower = Value
            if jumpEnabled then
                updateJump()
            end
        end
    end
})

-- Jump Type Dropdown (SECOND)
local JumpTypeDropdown = LocalPlayerTab:CreateDropdown({
    Name = "Jump Modification Type",
    Options = jumpTypes,
    CurrentOption = selectedJumpType,
    Flag = "JumpType",
    Callback = function(Option)
        if Option then
            selectedJumpType = Option
            if jumpEnabled then
                updateJump()
            end
        end
    end
})

-- Jump Toggle (LAST)
local JumpToggle = LocalPlayerTab:CreateToggle({
    Name = "Apply Jump",
    CurrentValue = false,
    Flag = "JumpEnabled", 
    Callback = function(Value)
        if Value ~= nil then
            jumpEnabled = Value
            updateJump()
            
            if Value then
                pcall(function()
                    Rayfield:Notify({
                        Title = "Jump Modifier",
                        Content = "Jump power set to " .. selectedJumpPower .. " using " .. selectedJumpType .. " method",
                        Duration = 2
                    })
                end)
            else
                pcall(function()
                    Rayfield:Notify({
                        Title = "Jump Modifier",
                        Content = "Jump power reset to default: " .. originalJumpPower,
                        Duration = 2
                    })
                end)
            end
        end
    end
})

-- GRAVITY SETTINGS --
-- Gravity Value Slider (FIRST)
local GravitySlider = LocalPlayerTab:CreateSlider({
    Name = "Gravity",
    Range = {0, 1000},
    Increment = 1,
    Suffix = "force",
    CurrentValue = originalGravity,
    Flag = "Gravity", 
    Callback = function(Value)
        if Value then
            selectedGravity = Value
            if gravityEnabled then
                updateGravity()
            end
        end
    end
})

-- Gravity Type Dropdown (SECOND)
local GravityTypeDropdown = LocalPlayerTab:CreateDropdown({
    Name = "Gravity Modification Type",
    Options = gravityTypes,
    CurrentOption = selectedGravityType,
    Flag = "GravityType",
    Callback = function(Option)
        if Option then
            selectedGravityType = Option
            if gravityEnabled then
                updateGravity()
            end
        end
    end
})

-- Gravity Toggle (LAST)
local GravityToggle = LocalPlayerTab:CreateToggle({
    Name = "Apply Gravity",
    CurrentValue = false,
    Flag = "GravityEnabled", 
    Callback = function(Value)
        if Value ~= nil then
            gravityEnabled = Value
            updateGravity()
            
            if Value then
                pcall(function()
                    Rayfield:Notify({
                        Title = "Gravity Modifier",
                        Content = "Gravity set to " .. selectedGravity .. " using " .. selectedGravityType .. " method",
                        Duration = 2
                    })
                end)
            else
                pcall(function()
                    Rayfield:Notify({
                        Title = "Gravity Modifier",
                        Content = "Gravity reset to default: " .. originalGravity,
                        Duration = 2
                    })
                end)
            end
        end
    end
})

-- Notify user that the script has loaded
Rayfield:Notify({
    Title = "ZytrixHub Loaded",
    Content = "This was scripted solo!",
    Duration = 3,
})

-- Anti-AFK (keep the script running)
local VirtualUser = game:GetService("VirtualUser")
LocalPlayer.Idled:Connect(function()
    VirtualUser:Button2Down(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
    wait(1)
    VirtualUser:Button2Up(Vector2.new(0, 0), workspace.CurrentCamera.CFrame)
end)